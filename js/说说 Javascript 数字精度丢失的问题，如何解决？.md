### ✅ 一、JavaScript 数字精度丢失的本质原因

JavaScript 中的数字（`Number`）遵循的是 **IEEE 754 双精度浮点数标准（64位）**。

浮点数在表示某些十进制小数时 **无法精确表示**，导致**精度丢失**。

#### 🎯 举例说明：

```
0.1 + 0.2 === 0.3  // false
0.1 + 0.2          // 0.30000000000000004
```

这是因为二进制不能精确表示 `0.1` 和 `0.2`，计算后就出现了误差。

### ✅ 二、哪些情况容易出现精度丢失？

| 场景           | 示例                                                     |
| -------------- | -------------------------------------------------------- |
| 小数相加       | `0.1 + 0.2`                                              |
| 精度较高的计算 | `9999999999999999 + 1 === 10000000000000000`（其实不等） |
| 金额运算       | 例如电商/支付系统中的金额加减                            |

### ✅ 三、解决方案有哪些？

#### ✅ 1. 使用 `toFixed()`、`toPrecision()` 进行格式化（适合显示）

```
let sum = 0.1 + 0.2;
console.log(sum.toFixed(2)); // "0.30"
```

⚠️ 注意：`toFixed()` 会返回字符串，不适合继续参与运算。

------

#### ✅ 2. 放大再缩小（常用于金额等场景）

```
function add(a, b) {
  return (a * 100 + b * 100) / 100;
}
add(0.1, 0.2); // 0.3
```

⚠️ 适合处理**位数确定的小数**（如两位小数的金额）。

------

#### ✅ 3. 使用第三方库（推荐）

- decimal.js
- [big.js](https://github.com/MikeMcl/big.js/)
- [bignumber.js](https://github.com/MikeMcl/bignumber.js)

```
import Decimal from 'decimal.js';
const result = new Decimal(0.1).plus(0.2);
console.log(result.toString()); // '0.3'
```

这些库底层用字符串精确存储数字，适合高精度运算（如财务系统）。

------

#### ✅ 4. ES2020 的 `BigInt`（用于处理大整数，不支持小数）

```
const a = 9007199254740991n;
const b = a + 1n;
console.log(b); // 9007199254740992n
```

------

### ✅ 四、总结

> JavaScript 中的数字精度丢失是由于 IEEE 754 浮点数表示方式导致的，常出现在小数计算和高精度运算中。解决方案包括格式化、放大缩小法、使用第三方库（如 decimal.js）、或用 BigInt 处理大整数。

------

### ✅ 口语化简短回答（面试版）

> JavaScript 采用 IEEE 754 浮点数标准，所以像 `0.1 + 0.2` 会出现 `0.30000000000000004` 这样的精度问题。
>  解决方式常见有三种：一是用 `toFixed` 做格式化，但适合展示不适合运算；二是先放大再除回来，常用于金额；三是使用像 `decimal.js` 这样的高精度库，能彻底解决精度丢失问题。