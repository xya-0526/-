# 内存泄漏

内存泄漏是指 某些不在使用的内存 没有被及时释放掉 被程序持续占用 

## JavaScript 中常见的内存泄漏场景

### 1. **意外的全局变量**

```
js复制编辑function test() {
  leak = "I am global"; // 没有用 var/let/const 声明
}
```

- `leak` 变成了全局变量，被挂在了 `window` 上，**无法被 GC 回收**。

------

### 2. **闭包未释放**

```
js复制编辑function outer() {
  let largeData = new Array(100000).fill("leak");
  return function inner() {
    console.log(largeData[0]);
  };
}
const closure = outer(); // outer 执行后，largeData 本应被回收，但因 inner 引用了它，无法释放
```

- 闭包引用了父作用域变量，导致不再需要的数据被长时间保留。

------

### 3. **DOM 引用未清除**

```
let div = document.getElementById('leakDiv');
document.body.removeChild(div); // 从 DOM 树中移除
// 但 div 变量仍然引用着 DOM，内存未释放
```

- JS 中仍持有 DOM 的引用，即使它已不在页面上，也不会被回收。

------

### 4. **定时器未清除（setInterval）**

```
const timer = setInterval(() => {
  console.log('running');
}, 1000);
// 页面关闭前未 clearInterval(timer)，内存无法释放
```

- `setInterval` 持续引用作用域，若不清除，引用永远存在。

------

### 5. **事件监听未移除**

```
js复制编辑const btn = document.getElementById('myBtn');
btn.addEventListener('click', function () {
  console.log('clicked');
});
// btn 被移除或隐藏后，如果没有 removeEventListener，回调依然引用 btn
```

- 事件回调闭包引用 DOM，导致泄漏。

------

### 6. **缓存滥用**

```
js复制编辑const cache = {};
function addToCache(key, value) {
  cache[key] = value; // 一直往 cache 塞数据，没有清理
}
```

## ✅ 三、内存泄漏带来的后果

- 页面越来越卡顿
- 频繁卡死或崩溃
- 资源消耗异常高，特别在 SPA 应用中明显

## ✅ 五、总结一句话（可用于面试结尾）

> JavaScript 中的内存泄漏主要来自于闭包引用、未清理的 DOM、定时器、事件监听等场景，开发中应注意引用管理和及时释放，尤其在复杂页面和 SPA 应用中更为关键。

# 垃圾回收与引用的关系

##  一、垃圾回收（GC）是什么？

> 垃圾回收（Garbage Collection）是 JS 引擎自动管理内存的机制，它会周期性地检查哪些变量不再被引用，并释放这些内存。

JavaScript 是 **自动垃圾回收语言**，开发者无需手动释放内存，但需要理解引用的规则，避免内存泄漏。

------

## ✅ 二、GC 与“引用”的关系？

### 🔁 **引用 = 是否还在被使用**

- 如果一个值**仍然能被访问到（有引用）**，它就不会被 GC。
- 如果一个值**再也无法被访问到（无引用）**，那么它就会被 GC 标记为“垃圾”，等待回收。

------

## ✅ 三、常见的垃圾回收算法

### 1. ✅ **标记清除（Mark-and-Sweep）**：主流 JS 引擎都使用它。

流程如下：

1. 从根对象（`window`）出发，标记所有“可达”对象。
2. 没有被标记的对象即“不可达”，会被清除。
3. 清除内存。

#### 示例：

```
js复制编辑let obj = { name: 'Alice' }; // 可达（有变量引用）
obj = null; // 不再被引用 → 等待 GC 清除
```

------

### 2. ✅ **引用计数（Reference Counting）**：早期 JS 引擎使用，现在已较少使用。

- 每个对象维护一个“引用数”
- 有引用时 +1，删除引用时 -1
- 引用数为 0 → 可被回收

#### 缺点：**循环引用无法释放**

```
js复制编辑const a = {};
const b = {};
a.self = b;
b.self = a;
// 引用计数都为 1，无法回收 → 内存泄漏
```

现代 JS 引擎已用 **“标记清除”** 解决循环引用问题。

------

## ✅ 四、引用的分类（哪些会保留内存）

| 引用位置          | 是否会阻止 GC？          |
| ----------------- | ------------------------ |
| 被函数/变量引用   | ✅ 是                     |
| 存在闭包中        | ✅ 是（闭包引用父作用域） |
| 保存在全局对象上  | ✅ 是                     |
| DOM 仍在页面中    | ✅ 是                     |
| `null` / 不再可达 | ❌ 否 → 会被 GC 回收      |



------

## ✅ 五、开发中如何避免“错误引用”导致内存泄漏？

- ✅ 及时清除不再需要的引用：如设置变量为 `null`
- ✅ 页面销毁时移除定时器、事件监听
- ✅ 避免闭包引用大量对象或 DOM 节点
- ✅ 避免全局变量污染

------

## ✅ 六、总结一句话（面试结尾）

> JavaScript 垃圾回收机制依赖于引用判断对象是否仍“可达”，只要某个对象还被引用，它就不会被释放，因此我们在开发中要避免无意义或长期的引用保留，才能减少内存泄漏和性能问题。