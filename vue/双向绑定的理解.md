# 双向绑定

简单说就是 ：数据改变 视图跟新 视图改变 数据更新

1.在vue 实例初始化后 vue会 遍历 data 里的属性并同过object.definePrepertry  设置拦截代理，并为每一个属性创建一个dep依赖收集齐器用于收集依赖该属性的whcher 实在Observe 中完成实现data 响应式

2. 模板编译 vue 会 查找模板中的动态绑定的数据 也就是 插值语法 或者 指令绑定的数据  然后得到 哪些数据被用到视图层 然后从 `data` 中获取这些数据的初始值，并将其渲染到视图上，完成视图的初始化。

    

3 Watcher 创建   在访问data 里的数据时 触发getter函数 ，在 `getter` 中，会将当前的 `Watcher` 添加到该属性对应的 `Dep` 中这样，`Dep` 就收集了所有依赖该属性的 `Watcher`，每个 `Watcher` 都关联着一个更新函数，该函数负责更新视图中对应的部分

4  在数据 发生变化时 会触发 setter函数 在setter函数这中 会通知 dep dep 通知 已经添加的 watcher调用关联的更新函数 进行视图更新

Vue 的双向绑定流程是通过响应式系统（`Observe`）、模板编译（`Compile`）、依赖收集（`Dep`）和视图更新（`Watcher`）共同实现的。通过这种方式，Vue 能够在数据发生变化时自动更新视图，同时也能在视图发生变化时（如用户输入）更新数据，从而实现双向绑定的效果。

#### 1. 数据响应式的实现

在 Vue 实例初始化后，Vue 会遍历 `data` 中的所有属性，并通过 `Object.defineProperty` 方法为每个属性设置 getter 和 setter，实现数据的劫持与代理。

同时，为每个属性创建一个 `Dep` 对象，用于依赖收集。这个过程是在 `Observer` 中完成的，也就是说 Vue 会把 `data` 中的属性变成响应式对象，每个属性背后都维护着一个依赖收集器 `Dep`。

#### 2. 模板编译与依赖收集

Vue 会编译模板，查找模板中使用的数据（如插值语法 `{{ message }}` 或指令绑定如 `v-bind:title="title"`），分析出哪些属性被视图层依赖。

此时 Vue 会读取 `data` 中的这些属性，从而触发属性的 `getter`，借此完成依赖收集（也就是将当前的 `Watcher` 添加到该属性的 `Dep` 中），并将初始数据渲染到视图中，实现初始渲染。

#### 3. Watcher 的创建与作用

每一个使用到响应式数据的地方，都会对应一个 `Watcher` 实例。比如一个插值表达式，或者一个计算属性，都会有一个 `Watcher` 来追踪它依赖的属性。

当模板编译时访问了某个响应式属性，会触发该属性的 `getter`，此时当前的 `Watcher` 会被添加到这个属性的 `Dep` 中，也就是说，这个 `Dep` 知道有哪些 `Watcher` 依赖它。

每个 `Watcher` 都包含一个更新函数，一旦数据变化，它就能执行对应的更新逻辑，完成视图的更新。

#### 4. 数据更新与视图响应

当响应式数据发生变化（即触发 `setter`）时，会通知该属性对应的 `Dep`。

`Dep` 会将所有收集到的 `Watcher` 遍历一遍，并调用它们的更新函数。每个 `Watcher` 的更新函数会根据新数据重新渲染 DOM 中对应的部分，从而实现视图的响应式更新。
$$
初始化 -> 遍历 data -> defineProperty 劫持属性 -> 创建 Dep

模板编译 -> 访问 data 属性 -> 触发 getter -> Dep 收集 Watcher

数据变化 -> 触发 setter -> Dep 通知 Watcher -> Watcher 更新视图
$$


